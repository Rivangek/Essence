{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Welcome to the Essence documentation! Thanks for choosing my framework as the pillar for your plugin or game! Why Essence over others? Built over Roact syntax, don't loose familiarity. Lightweight library, don't worry about 5,000 lines source code. You can interact with Components outside the Render function and access the Production Element children. Features of Essence Visual editor, no more monotone scripting. Re-usable components which you can edit with visual editor.","title":"Introduction"},{"location":"#introduction","text":"Welcome to the Essence documentation! Thanks for choosing my framework as the pillar for your plugin or game!","title":"Introduction"},{"location":"#why-essence-over-others","text":"Built over Roact syntax, don't loose familiarity. Lightweight library, don't worry about 5,000 lines source code. You can interact with Components outside the Render function and access the Production Element children.","title":"Why Essence over others?"},{"location":"#features-of-essence","text":"Visual editor, no more monotone scripting. Re-usable components which you can edit with visual editor.","title":"Features of Essence"},{"location":"installation/","text":"Installation Wally If you are using Wally package manager, then insert this to your wally.toml [dependencies] Essence = \"rivangek/essence@1.0.0\" That will clone the repository into your packages. Rojo Sync Download the repository and then build the build.project.json file using the command prompt with the rojo command, this will give you the latest version of Essence with the latest features. Note that this build might be unsafe to use and not production-ready. Production ready Download the latest stable version from GitHub releases page and place it in your Roblox explorer or VSCode explorer(if you're using Rojo)","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#wally","text":"If you are using Wally package manager, then insert this to your wally.toml [dependencies] Essence = \"rivangek/essence@1.0.0\" That will clone the repository into your packages.","title":"Wally"},{"location":"installation/#rojo-sync","text":"Download the repository and then build the build.project.json file using the command prompt with the rojo command, this will give you the latest version of Essence with the latest features. Note that this build might be unsafe to use and not production-ready.","title":"Rojo Sync"},{"location":"installation/#production-ready","text":"Download the latest stable version from GitHub releases page and place it in your Roblox explorer or VSCode explorer(if you're using Rojo)","title":"Production ready"},{"location":"tutorials/first_component/","text":"Creating a Component So, let's start with the first Component of the day, it will be a button which increments it's text when clicked. ExampleComponent.luau local Component = {} local Essence = require ( game . ReplicatedStorage . Essence ) function Component : Render ( props ) return Essence . new ( \"ImageButton\" , { Parent = game . Players . LocalPlayer . PlayerGui : WaitForChild ( \"ScreenGui\" ), Size = UDim2 . fromOffset ( 200 , 50 ), Image = \"\" , Children = { Label = Essence . new ( \"TextLabel\" , { Size = UDim2 . fromScale ( 1 , 1 ), Text = Essence . getState ( \"Clicks\" , props . InitialClicks ), }) } }) end -- This function only does exist -- on production component. function Component : Increment () self . Label . State . Clicks += 1 end -- local PComp = Essence . build ( Essence . new ( Component , { InitialClicks = 20 , }) ) PComp . Instance . MouseButton1Click : Connect ( function () PComp : Increment () end ) As you can see, you can directly interact like if it was an actual Roblox instance, this is extremely helpful when creating plugins. And if you're wondering about the result, you can see it here:","title":"Creating a Component"},{"location":"tutorials/first_component/#creating-a-component","text":"So, let's start with the first Component of the day, it will be a button which increments it's text when clicked. ExampleComponent.luau local Component = {} local Essence = require ( game . ReplicatedStorage . Essence ) function Component : Render ( props ) return Essence . new ( \"ImageButton\" , { Parent = game . Players . LocalPlayer . PlayerGui : WaitForChild ( \"ScreenGui\" ), Size = UDim2 . fromOffset ( 200 , 50 ), Image = \"\" , Children = { Label = Essence . new ( \"TextLabel\" , { Size = UDim2 . fromScale ( 1 , 1 ), Text = Essence . getState ( \"Clicks\" , props . InitialClicks ), }) } }) end -- This function only does exist -- on production component. function Component : Increment () self . Label . State . Clicks += 1 end -- local PComp = Essence . build ( Essence . new ( Component , { InitialClicks = 20 , }) ) PComp . Instance . MouseButton1Click : Connect ( function () PComp : Increment () end ) As you can see, you can directly interact like if it was an actual Roblox instance, this is extremely helpful when creating plugins. And if you're wondering about the result, you can see it here:","title":"Creating a Component"},{"location":"tutorials/hierarchy/","text":"Production Element Hierarchy If you're wondering about the hierarchy in the ProductionElement result of Essence.build with typos, it is the following: Element State: { [string]: any } Properties: { [string]: any } Instance: Instance Parent: Element or nil Any other index will be considered a child and will error if doesn't exist. This hierarchy allows you to interact with the element externally without using state managment internally.","title":"Hierarchy"},{"location":"tutorials/hierarchy/#production-element-hierarchy","text":"If you're wondering about the hierarchy in the ProductionElement result of Essence.build with typos, it is the following: Element State: { [string]: any } Properties: { [string]: any } Instance: Instance Parent: Element or nil Any other index will be considered a child and will error if doesn't exist. This hierarchy allows you to interact with the element externally without using state managment internally.","title":"Production Element Hierarchy"},{"location":"tutorials/properties/","text":"","title":"Properties from Object"},{"location":"tutorials/renderize_function/","text":"Well, as you can see in the code, there's a renderize function which can be called with no arguments but still does something, it basically renders the build that you generated with the Essence inspector, note that isn't for plugins as it renders a game interface data build. Generating the Build You can generate a build for your game interface data with the \"Build\" tab inside Essence inspector, after you clicked it, it will build an optimized data that you can use for production games and can render with the Essence.renderize function.","title":"Renderize function"},{"location":"tutorials/renderize_function/#generating-the-build","text":"You can generate a build for your game interface data with the \"Build\" tab inside Essence inspector, after you clicked it, it will build an optimized data that you can use for production games and can render with the Essence.renderize function.","title":"Generating the Build"},{"location":"tutorials/state_managment/","text":"Using Basic States BasicState.luau local Element = Essence . new ( \"TextLabel\" , { Text = Essence . getState ( \"CurrentText\" , \"Initial value!\" ) }) local Production = Essence . build ( Element ) Production . State . CurrentText = \"Override!\" As you can see, using Essence.getState you can create a new state value which can be modified externally by the State metatable, optionally, you can also assign an initial value to the state as second parameter of the function. Compute State If you want to concenate the State or do advanced computations with the new value, you can use the third parameter of Essence.getState which is a function that returns the new state value to be displayed to that property. Here's an example: ComputeState.luau local Element = Essence . new ( \"TextLabel\" , { Text = Essence . getState ( \"CurrentNumber\" , 5 , function ( Value : any ) return \"Computation: \" .. Value end ) }) local Production = Essence . build ( Element ) Production . State . CurrentNumber = 10 Children State Sadly, you can't interact externally with the children added to the Element, fortunately this is solved by using state as the children parameter. ChildrenState.luau local Element = Essence . new ( \"TextLabel\" , { Text = \"Hi mom!\" , Children = Essence . getState ( \"BelovedChildren\" ) }) local Production = Essence . build ( Element ) Production . State . BelovedChildren = { Test = Essence . new ( \"Frame\" , { BackgroundColor3 = Essence . getState ( \"Color\" ) }) } As you can see, you cannot interact with the children state directly but there is a new property that solves it: local BelovedChildren = Production . State . BelovedChildren BelovedChildren . _Objects . Test . State . Color = Color3 . fromRGB ( 255 , 0 , 0 ) This new property is overriden each time you set the children state so don't make variables with it as it is unsafe for memory to reference destroyed children. Centralized States Centralized states are a way to inherit the parent state and center the state in only one element instead of spreading the states across all elements from a Component. CentralizedState.lua local Component = {} -- And here is where the magics happen Component . State = { Color = Color3 . new ( 1 , 0 , 0 ) } function Component : Render () return Essence . new ( \"Frame\" , { BackgroundColor3 = Essence . getState ( \"Color\" , \"__CENTRALIZED\" ) }) end -- local PComp = Essence . build ( Essence . new ( Component , {})) PComp . ComponentState . Color = Color3 . new ( 0 , 0 , 1 ) Sadly centralized states do not work with children states for compatibility reasons.","title":"State Managment"},{"location":"tutorials/state_managment/#using-basic-states","text":"BasicState.luau local Element = Essence . new ( \"TextLabel\" , { Text = Essence . getState ( \"CurrentText\" , \"Initial value!\" ) }) local Production = Essence . build ( Element ) Production . State . CurrentText = \"Override!\" As you can see, using Essence.getState you can create a new state value which can be modified externally by the State metatable, optionally, you can also assign an initial value to the state as second parameter of the function.","title":"Using Basic States"},{"location":"tutorials/state_managment/#compute-state","text":"If you want to concenate the State or do advanced computations with the new value, you can use the third parameter of Essence.getState which is a function that returns the new state value to be displayed to that property. Here's an example: ComputeState.luau local Element = Essence . new ( \"TextLabel\" , { Text = Essence . getState ( \"CurrentNumber\" , 5 , function ( Value : any ) return \"Computation: \" .. Value end ) }) local Production = Essence . build ( Element ) Production . State . CurrentNumber = 10","title":"Compute State"},{"location":"tutorials/state_managment/#children-state","text":"Sadly, you can't interact externally with the children added to the Element, fortunately this is solved by using state as the children parameter. ChildrenState.luau local Element = Essence . new ( \"TextLabel\" , { Text = \"Hi mom!\" , Children = Essence . getState ( \"BelovedChildren\" ) }) local Production = Essence . build ( Element ) Production . State . BelovedChildren = { Test = Essence . new ( \"Frame\" , { BackgroundColor3 = Essence . getState ( \"Color\" ) }) } As you can see, you cannot interact with the children state directly but there is a new property that solves it: local BelovedChildren = Production . State . BelovedChildren BelovedChildren . _Objects . Test . State . Color = Color3 . fromRGB ( 255 , 0 , 0 ) This new property is overriden each time you set the children state so don't make variables with it as it is unsafe for memory to reference destroyed children.","title":"Children State"},{"location":"tutorials/state_managment/#centralized-states","text":"Centralized states are a way to inherit the parent state and center the state in only one element instead of spreading the states across all elements from a Component. CentralizedState.lua local Component = {} -- And here is where the magics happen Component . State = { Color = Color3 . new ( 1 , 0 , 0 ) } function Component : Render () return Essence . new ( \"Frame\" , { BackgroundColor3 = Essence . getState ( \"Color\" , \"__CENTRALIZED\" ) }) end -- local PComp = Essence . build ( Essence . new ( Component , {})) PComp . ComponentState . Color = Color3 . new ( 0 , 0 , 1 ) Sadly centralized states do not work with children states for compatibility reasons.","title":"Centralized States"},{"location":"tutorials/using_fragments/","text":"Using Fragments Fragments are a way to create multiple objects in a same build, think of it like Roact fragments as this library is highly inspired by Roact. -- The second parameter are the children. local Fragment = Essence . new ( \"Fragment\" , { Frame1 = Essence . new ( \"Frame\" , { BackgroundColor3 = Color3 . fromRGB ( 255 , 0 , 0 ) }) }) And it's done, you just created your first fragment! And if you're wondering if you can use state managment in fragments, the answer is yes; the logic behind the state in fragments it's the same as the children state logic. Example of state managment in Fragments: -- The second parameter are the children. local Fragment = Essence . new ( \"Fragment\" , Essence . getState ( \"BelovedChildren\" , {})) local ProductionElement = Essence . build ( Fragment ) ProductionElement . State . BelovedChildren = { Frame1 = Essence . new ( \"Frame\" , { BackgroundColor3 = Color3 . fromRGB ( 255 , 0 , 0 ) }) } Note that the second parameter of getState (the initial value) must be a table or the entire function will error because it tries to iterate over null object.","title":"Using Fragments"},{"location":"tutorials/using_fragments/#using-fragments","text":"Fragments are a way to create multiple objects in a same build, think of it like Roact fragments as this library is highly inspired by Roact. -- The second parameter are the children. local Fragment = Essence . new ( \"Fragment\" , { Frame1 = Essence . new ( \"Frame\" , { BackgroundColor3 = Color3 . fromRGB ( 255 , 0 , 0 ) }) }) And it's done, you just created your first fragment! And if you're wondering if you can use state managment in fragments, the answer is yes; the logic behind the state in fragments it's the same as the children state logic. Example of state managment in Fragments: -- The second parameter are the children. local Fragment = Essence . new ( \"Fragment\" , Essence . getState ( \"BelovedChildren\" , {})) local ProductionElement = Essence . build ( Fragment ) ProductionElement . State . BelovedChildren = { Frame1 = Essence . new ( \"Frame\" , { BackgroundColor3 = Color3 . fromRGB ( 255 , 0 , 0 ) }) } Note that the second parameter of getState (the initial value) must be a table or the entire function will error because it tries to iterate over null object.","title":"Using Fragments"}]}